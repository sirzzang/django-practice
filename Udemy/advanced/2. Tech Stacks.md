# Technologies



* Python: 3.7
  * Application logic and tests
  * PEP-8
  * automated code linting

* Django: Python web framework

  * build web apps ratpidly

  * Django ORM(Object Relational Mapper)

    * convert **objects** to **database rows**

      *ex*. Django model automatically creating recipe objects recipe table

    * easy-to-use interface for managing rows in the table

  * Django admin

    * out-of-the-box admin site for managing objects in database
    * useful when developing and testing on local machine

* Django REST framework: extension to Django

  * useful features for building REST APIs
  * built-in authentication system: add authentication to API endpoints
  * Django REST framework viewsets: creating the structure of API and providing all of the necessary endpoints
  * Serializers: validation on requests, converting JSON objects to Django DB models
  * Browsable API: testing endpoints in the browser

* Docker: virtualization
  * isolating project dependencies from the machine
  * lightweight virtual machine
  * single inage that can be run independently on any machine
  * consistent development environments
  * deploy project to a cloud platform

* Travis CI
  * automate testing and linting
  * integrate well with Github
  * configure Travis-CI to run a script every time when changes made
* Postgres: DB for the project
  * opensorce production grade DB
  * easy to setup with Docker



<br>

# TDD

 Test Driven Development



## Unit Tests

* unit tests for checking that the code works

* start by **isolating** the particular piece of code to be tested

  * **function**, **class**

    ![image-20210320232647793](images/image-20210320232647793.png)

  * making the actual **API** calls to endpoints

* test stages: setup → execution → assertion 

  * setup: create sample DB objects 

    *ex*. testing API endpoint that updates a recipe we would start by creating a sample recipe that we can use to test our endpoint

    ```python
    def test_partial_update_recipe(self):
        '''test updating a recipe with patch'''
        recipe = sample_recipe(user=self.user)
        recipe.tags.add(sample_Tag(user=self.user))
        new_tag = sample_tag(user=self.user, name='Curry')
    ```

  * execution: call the code

    *ex*. call our recipe update endpoint with our test client with the ID of the sample recipe and some sample fields to update

    ```python
    def test_partial_update_recipe(self):
        '''test updating a recipe with patch'''
    	...
        
        payload = {'title': 'Chicken tikka', 'tags': [new_tag.id]}
        url = detail_url(recipe.id)
        self.client.patch(url, payload)
    ```

  * assertion: confirm expected output

    *ex*. ensure that the appropriate fields on our sample recipe were updated to the correct values

    ```python
    def test_partial_update_recipe(self):
        '''test updating a recipe with patch'''
    	...
        
        recipe.refresh_from_db()
        self.assertEqual(recipe.title, payload['title'])
        tags = recipe.tags.all()
        self.assertEqual(len(tags), 1)
        self.assertIn(new_tag, tags)
    ```

    

## Why write tests?

* easier to change code: great test coverage → when something breaks as a side effect of a change, then it will be known when the test is run
* save time: adding feature and making changes becomes a lot easier with the confidence that tests bring
* testable, better quality code: clear input and output for each unit of code



## TDD

<img src="images/image-20210320234424785.png" alt="image-20210320234424785" style="zoom: 33%;" />

* start by writing unit tests
* when test failes, then implement the code or feature to make the test pass



## Why use TDD?

* increase test coverage
* ensure tests work
* encourages quality code
* guideline for when to stop coding



